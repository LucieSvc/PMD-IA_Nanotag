##########################################
##### Creation images modifi√©es ########
import os
import cv2
import numpy as np
import random

# Appliquer une rotation sans compl√©ter l'image avec des bords artificiels
def rotate_and_crop(image, angle_range=(-180,180)):  
    # G√©n√©rer un angle al√©atoire
    angle = random.uniform(*angle_range)
    h, w = image.shape[:2]
    center = (w // 2, h // 2)

    # Calcul de la matrice de rotation
    rotation_matrix = cv2.getRotationMatrix2D(center, angle, 1)

    # Appliquer la rotation avec warpAffine
    rotated_image = cv2.warpAffine(image, rotation_matrix, (w, h), borderMode=cv2.BORDER_REPLICATE)

    return rotated_image


# Zoom avant uniquement
def zoom_in(image, zoom_range=(1.0, 1.3)):
    scale = random.uniform(*zoom_range)
    h, w = image.shape[:2]
    new_h, new_w = int(h / scale), int(w / scale)

    start_x, start_y = (w - new_w) // 2, (h - new_h) // 2
    cropped = image[start_y:start_y + new_h, start_x:start_x + new_w]
    return cv2.resize(cropped, (w, h), interpolation=cv2.INTER_CUBIC)

# Modifier la luminosit√© et le contraste
def adjust_brightness_contrast(image, alpha_range=(0.9, 1.1), beta_range=(-20, 20)):
    alpha = random.uniform(*alpha_range)
    beta = random.randint(*beta_range)
    return cv2.convertScaleAbs(image, alpha=alpha, beta=beta)

# Modifier l√©g√®rement les couleurs
def modify_colors(image, hue_shift=(-10, 10), saturation_scale=(0.9, 1.1)):
    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV).astype(np.float32)
    hsv[:, :, 0] = (hsv[:, :, 0] + random.randint(*hue_shift)) % 180
    hsv[:, :, 1] *= random.uniform(*saturation_scale)
    return cv2.cvtColor(hsv.astype(np.uint8), cv2.COLOR_HSV2BGR)

# Appliquer un effet de lumi√®re avec un d√©grad√© doux
def add_light_effect(image, intensity_range=(0.2, 0.4)):
    h, w = image.shape[:2]
    mask = np.ones((h, w), dtype=np.float32)

    x, y = random.randint(w//4, 3*w//4), random.randint(h//4, 3*h//4)
    radius = random.randint(h//3, h//2)

    for i in range(h):
        for j in range(w):
            dist = np.sqrt((i - y) ** 2 + (j - x) ** 2)
            mask[i, j] = min(1.0, 1.0 + random.uniform(*intensity_range) * (radius - dist) / radius)

    mask = cv2.GaussianBlur(mask, (101, 101), 0)
    mask = np.repeat(mask[:, :, np.newaxis], 3, axis=2)

    brightened_image = cv2.addWeighted(image.astype(np.float32), 1.0, mask * 255, 0.2, 0)
    return np.clip(brightened_image, 0, 255).astype(np.uint8)

# Ajouter une ombre douce avec un d√©grad√©
def add_shadow_effect(image, intensity_range=(-0.3, -0.1)):
    h, w = image.shape[:2]
    mask = np.ones((h, w), dtype=np.float32)

    x, y = random.randint(w//4, 3*w//4), random.randint(h//4, 3*h//4)
    radius = random.randint(h//3, h//2)

    for i in range(h):
        for j in range(w):
            dist = np.sqrt((i - y) ** 2 + (j - x) ** 2)
            mask[i, j] = max(0.7, 1.0 + random.uniform(*intensity_range) * (radius - dist) / radius)

    mask = cv2.GaussianBlur(mask, (101, 101), 0)
    mask = np.repeat(mask[:, :, np.newaxis], 3, axis=2)

    shadowed_image = (image * mask).astype(np.uint8)
    return shadowed_image

# Modifier l'inclinaison (effet de perspective)
def skew_image(image, max_skew=0.05):
    h, w = image.shape[:2]

    src_pts = np.float32([[0, 0], [w, 0], [0, h], [w, h]])
    dst_pts = src_pts + np.float32([
        [random.uniform(-max_skew*w, max_skew*w), random.uniform(-max_skew*h, max_skew*h)],
        [random.uniform(-max_skew*w, max_skew*w), random.uniform(-max_skew*h, max_skew*h)],
        [random.uniform(-max_skew*w, max_skew*w), random.uniform(-max_skew*h, max_skew*h)],
        [random.uniform(-max_skew*w, max_skew*w), random.uniform(-max_skew*h, max_skew*h)]
    ])

    matrix = cv2.getPerspectiveTransform(src_pts, dst_pts)
    return cv2.warpPerspective(image, matrix, (w, h), borderMode=cv2.BORDER_REFLECT)

# Appliquer plusieurs transformations al√©atoires √† une image
def apply_random_transformations(image):
    transformations = [
        rotate_and_crop, zoom_in, adjust_brightness_contrast, modify_colors,
        add_light_effect, add_shadow_effect, skew_image
    ]
    
    num_modifications = random.randint(1, 4)  # Appliquer entre 1 et 4 les modifications
    random.shuffle(transformations)
    
    for i in range(num_modifications):
        image = transformations[i](image)
    
    return image

# G√©n√©ration des variations avec transformations multiples
def generate_variations(input_dir, output_dir, num_variations):
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)

    for filename in os.listdir(input_dir):
        if filename.endswith(('.jpg', '.jpeg', '.png')):
            img_path = os.path.join(input_dir, filename)
            image = cv2.imread(img_path)

            if image is None:
                print(f"Erreur de lecture : {filename}")
                continue

            base_name, ext = os.path.splitext(filename)

            transformations = [rotate, zoom_in, adjust_brightness_contrast, modify_colors, add_light_effect, add_shadow_effect, skew_image]
            for i in range(7) : 
                modified_image =  transformations[i](image)
                output_path = os.path.join(output_dir, f"{base_name}_{transformations[i].__name__}{ext}")
                cv2.imwrite(output_path, modified_image)
                print(transformations[i])

            for i in range(num_variations):
                modified_image = apply_random_transformations(image)
                output_path = os.path.join(output_dir, f"{base_name}_mod_{i}{ext}")
                cv2.imwrite(output_path, modified_image)
                print("ok2")

            print(f"Variations g√©n√©r√©es pour {filename}")

    print("Toutes les modifications sont termin√©es !")

# √âtape 1 : G√©n√©rer des variations avec transformations multiples
generate_variations('./modif/og', './modif', num_variations=2)
####################################



####################################
######## Recadrage + Noir et Blanc ###############
import cv2
import os
import numpy as np

# Chemins des dossiers source et destination
"""source_dir = r".\donnees\originales"
destination_dir = r".\donnees\resized2\originales"""

source_dir = r".\donnees\train"
destination_dir = r".\donnees\resized2\train"

"""source_dir = r".\donnees\test"
destination_dir = r".\donnees\resized2\test"""

# Dimensions pour le redimensionnement
resize_width, resize_height = 480, 256

# Parcourir tous les fichiers et dossiers
for root, _, files in os.walk(source_dir):
    for file in files:
        if file.lower().endswith(('.png', '.jpg', '.jpeg', '.bmp', '.tiff')):  # Filtrer les images
            source_path = os.path.join(root, file)
            
            # Construire le chemin de destination en conservant la structure
            relative_path = os.path.relpath(source_path, source_dir)
            destination_path = os.path.join(destination_dir, relative_path)
            destination_folder = os.path.dirname(destination_path)
            os.makedirs(destination_folder, exist_ok=True)

            # Charger l'image
            image0 = cv2.imread(source_path)

            if image0 is None:
                print(f"Erreur : Impossible de charger {source_path}")
                continue

            # Redimensionner l'image √† 480x256 pour la d√©tection du cercle
            image = cv2.resize(image0, (resize_width, resize_height))

            # Convertir en niveaux de gris
            gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

            # D√©tecter les cercles avec HoughCircles
            circles = cv2.HoughCircles(gray, cv2.HOUGH_GRADIENT, dp=1.2, minDist=300, param1=100, param2=10, minRadius=100, maxRadius=200)

            # Dimensions de l'image redimensionn√©e
            height, width = gray.shape
            center_x, center_y = width // 2, height // 2

            # S√©lectionner le cercle le plus proche du centre de l'image
            best_circle = None
            min_distance = float("inf")

            if circles is not None:
                for circle in circles[0, :]:
                    x, y, r = circle
                    distance_to_center = np.sqrt((x - center_x) ** 2 + (y - center_y) ** 2)
                    if distance_to_center < min_distance:
                        min_distance = distance_to_center
                        best_circle = circle
            
            # Si un cercle a √©t√© d√©tect√©, ajuster ses coordonn√©es √† l'image originale
            if best_circle is not None:
                x, y, r = best_circle  # Coordonn√©es du cercle sur l'image redimensionn√©e
                
                # Mise √† l'√©chelle des coordonn√©es et du rayon
                scale_x = image0.shape[1] / resize_width
                scale_y = image0.shape[0] / resize_height
                x = int(x * scale_x)
                y = int(y * scale_y)
                r = int(r * min(scale_x, scale_y))  # Adapter le rayon

                # D√©finir la r√©gion de recadrage
                x1, y1 = max(0, x - r), max(0, y - r)
                x2, y2 = min(image0.shape[1], x + r), min(image0.shape[0], y + r)

                # Recadrer l'image sur l'image originale
                cropped_image = image0[y1:y2, x1:x2]

                # Convertir en noir et blanc
                cropped_gray = cv2.cvtColor(cropped_image, cv2.COLOR_BGR2GRAY)

                # Enregistrer l'image recadr√©e
                cv2.imwrite(destination_path, cropped_gray)
                print(f"‚úÖ Image sauvegard√©e : {destination_path}")

print("üöÄ Traitement termin√© pour toutes les images !")
